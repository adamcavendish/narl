#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass scrartcl
\use_default_options true
\begin_modules
logicalmkup
minimalistic
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman newcent
\font_sans berasans
\font_typewriter beramono
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered true
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks true
\pdf_pdfborder true
\pdf_colorlinks false
\pdf_backref section
\pdf_pdfusetitle true
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation skip
\defskip smallskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\listings_params "basicstyle={\ttfamily\footnotesize},breaklines=true,extendedchars=true,language={[ANSI]C++},showstringspaces=false,tabsize=4"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
C++ Range and Elevation
\end_layout

\begin_layout Author
Steve Love
\end_layout

\begin_layout Date
September 2013
\end_layout

\begin_layout Subject
C++ provides many features for higher-level programming, but lacks some
 common ones present in other languages.
\end_layout

\begin_layout Standard
Back in 2009, Andrei Alexandrescu gave a presentation at the ACCU Conference
 about Ranges.
 The short version is that although you can 
\emph on
represent
\emph default
 a range in C++98 using a pair of iterators, the 
\emph on
usage
\emph default
 is cumbersome for most simple tasks.
 Even for a simple loop, using iterators can be a trial.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}
\end_layout

\begin_layout Plain Layout

for( vector< int >::iterator pos = data.begin(); pos != data.end(); ++pos
 )
\end_layout

\begin_layout Plain Layout

{ 	
\end_layout

\begin_layout Plain Layout

	....
 do interesting things with ints 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The C++ Standard Library provides a simple enough algorithm which improves
 on this a bit, but you need to provide the action to be performed as a
 functor argument, thus losing the locality of reference for that action.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}
\end_layout

\begin_layout Plain Layout

for_each( data.begin(), data.end(), action );
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
And all that's just using the iterators the C++ Standard Library gives you;
 defining your own iterator is notoriously complex.
 So, Andrei introduced a much simpler - and more powerful - abstraction:
 the Range [1].
 
\end_layout

\begin_layout Standard
There have been a few attempts to implement Andrei's ideas in C++ (he implemente
d them for D, and they form the basis of the D Standard Library) but for
 one reason or another, it just hasn't caught on.
 Part of the reason for that is that in order to take advantage of this
 new abstraction as Andrei envisioned it, you need a rewrite of the Standard
 Library that uses Ranges instead of Iterators.
 For some reason, there seems to be little appetite for this.
 Some implementations have arisen that are interoperable with C++ Standard
 Library algorithms [2], [3], but even they appear to not have had as much
 traction in the C++ community at large as might have been hoped.
 Similarly, there have been proposals to the C++ Standards effort [4], but
 still, not much apparent interest in something that is little more than
 a thin wrapper around the existing C++ container types which are, after
 all, really just iterator factories.
\end_layout

\begin_layout Standard
Part of the reason Andrei himself implemented his idea of Ranges in D, rather
 than C++, was that C++ at the time didn't provide good enough language
 support to make it straightforward.
 In particular, there was a C++ proposal at the time for "auto" variable
 declarations, which would have been crucial, but had experimental support
 in only one widely used compiler.
 Now, C++ officialy has 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!auto!
\end_layout

\end_inset

, and it's very widely supported.
 But not a widely-used - let alone standard - range type.
\end_layout

\begin_layout Standard
All of this is highly relevant, of course, but misses an important point:
 what do these range types actually achieve? What problem are they attempting
 to solve?
\end_layout

\begin_layout Standard
Time for a quick segue into a different world....
\end_layout

\begin_layout Section
The cross-pollination conundrum
\end_layout

\begin_layout Standard
It's common knowledge among experienced programmers that an intimate understandi
ng of a few different languages (and a possibly less intimate knowledge
 of many) is a good thing.
 Techniques from one language can inform and inspire neat solutions to problems
 in other languages.
 It's also common knowledge among experienced programmers that idiomatic
 features of one language are not necessarily transferrable to other languages,
 and that doing so can result in code that is truly incomprehensible to
 its readers.
 With both of those things in mind, I want to explore a little modern C#
 idiom: 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!IEnumerable!
\end_layout

\end_inset

, the C# Iterator.
\end_layout

\begin_layout Standard
This interface is what permits the 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!foreach!
\end_layout

\end_inset

 loop in C#:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[language={[Sharp]C}]
\end_layout

\begin_layout Plain Layout

foreach( var item in container ) 
\end_layout

\begin_layout Plain Layout

{ 
\end_layout

\begin_layout Plain Layout

	....
 do interesting things with items 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
C# has had 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!IEnumerable!
\end_layout

\end_inset

 from the very beginning, although it's undergone a few revisions over the
 years.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!IEnumerable!
\end_layout

\end_inset

 forms the basis of a much higher-level abstraction than merely accessing
 the contents of containers, however.
 It underpins all the functionality of LINQ 
\begin_inset Foot
status open

\begin_layout Plain Layout
Specifically, LINQ for Objects, which operate on containers rather than
 DataSources.
\end_layout

\end_inset

, introduced in Visual Studio 2005 with .Net 3.5, and builds on one key feature
 of .Net 2.0 - the 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!yield!
\end_layout

\end_inset

 keyword, which creates an 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!IEnumerable!
\end_layout

\end_inset

 
\series bold
on demand
\series default
 (actually, it creates an implementation of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!IEnumerator<T>!
\end_layout

\end_inset

, which is the 
\emph on
real
\emph default
 iterator type).
 This facility means that iterating over an 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!IEnumerable!
\end_layout

\end_inset

 is lazy - access to an element isn't performed until it's asked for.
 In C#, this is referred to as Deferred Execution.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[language={[Sharp]C}]
\end_layout

\begin_layout Plain Layout

var results = container.Where( item => item.Id == expected )
\end_layout

\begin_layout Plain Layout

					   .Select( filtered => filtered.Count.ToString() )
\end_layout

\begin_layout Plain Layout

					   .Take( 2 );
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The reason lazy access is important is that no matter how many elements
 "container" has, the clauses for 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!Where!
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!Select!
\end_layout

\end_inset

 will be called a maximum of 2 times.
 Obviously, this is significant if 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!container!
\end_layout

\end_inset

 has 20 million items in it.
\end_layout

\begin_layout Standard
So what has all this to do with C++? In the first case, the reason that
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!IEnumerable!
\end_layout

\end_inset

 works 
\emph on
as an interface
\emph default
 in C# is that it is implemented by all the standard containers, and is
 in fact very simple to implement for your own container types.
 C++ has no such interface, and in fact, there is no actual relationship
 - inheritance or otherwise - between the standard containers, or their
 iterator types.
 In the second case, does this entirely idiomatic C# translate at all into
 C++? Or does it make for an incomprehensible mess? That is the nature of
 the cross-pollination conundrum.
\end_layout

\begin_layout Section
The missing lin[qk]?
\end_layout

\begin_layout Standard
It should be clear that 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!IEnumerable!
\end_layout

\end_inset

 in C# has much more in common with Andrei Alexandrescu's vision of a Range
 than it does with C++ iterators - or even iterator pairs.
 C++ introduces many language features which allow a neat syntax for it,
 such as lambda and type deduction facilities.
 Suppose there were a range type in C++; would it on its own enable the
 implementation of something like 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!Select!
\end_layout

\end_inset

 or 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!Where!
\end_layout

\end_inset

 from C#? What might that look like?
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}
\end_layout

\begin_layout Plain Layout

auto result = container
\end_layout

\begin_layout Plain Layout

	.where( [&]( const thing & t ) { return t.name == expected; } ) 
\end_layout

\begin_layout Plain Layout

	.select( []( const thing & t ) { return to_string( t.count ); } ) 
\end_layout

\begin_layout Plain Layout

	.take( 2 );
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
It's not inconceivable.
 
\end_layout

\begin_layout Standard
But.
\end_layout

\begin_layout Standard
What type is container? We could implement a single type that has 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!where!
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!select!
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!take!
\end_layout

\end_inset

 and all the other things needed as member functions.
 What really makes C#'s 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!IEnumerable!
\end_layout

\end_inset

 work is the existence of extension methods.
 The power of that mechanism really shines through when you need to write
 your own function that fits in with other LINQ facilities, and C++ has
 no analogue for that.
 
\end_layout

\begin_layout Standard
A much neater idea would be closer to the Alexandrescu range concept whereby
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!select!
\end_layout

\end_inset

 returns a specific kind of range, and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!where!
\end_layout

\end_inset

 returns a different kind of range.
 The chaining of those operations together as shown above would still require
 some common base interface, and would still be hard to extend.
\end_layout

\begin_layout Standard
Lastly there is also the question of lazy evaluation (or Deferred Execution)
 and efficiency.
 It's hard to see how to make lazy evaluation safe in the above scenario,
 without resorting to passing functions around under the hood and capturing
 state.
 As for efficiency, this idea of a single base class is raising the spectre
 of allocating stuff on the heap (
\series bold
gasp!
\series default
), and too many C++ programmers have got used to the flexibility and efficiency
 of templates and type deduction of iterators to give it up that easily.
\end_layout

\begin_layout Standard
So, there are questions.
\end_layout

\begin_layout Standard
Perhaps we should wind back our expectations a little, start with something
 very, very simple, and see if it can be implemented.
 Then we can look to see if we can build on small beginnings to do something
 more elaborate.
 
\end_layout

\begin_layout Standard
So.
 Where do we start?
\end_layout

\begin_layout Section
Write a test
\end_layout

\begin_layout Standard
For the purposes of testing examples, assumptions and results, I'm using
 Catch [5] because it's easy to read, clear to write and not too verbose.
\end_layout

\begin_layout Standard
It should be obvious by now that the first step is to define a very simple
 and lightweight range type, upon which we can somehow "hang" all of the
 operations we need.
 This range should be trivially initialisable from some standard container.
 I'm going to make a conceptual leap here, because it's clear the range
 type needs a way to access the "current" element, and to move forwards
 one position.
 With these operations, it's possible to make a simple check that the "contents"
 of the range match the original data.
 Andrei Alexandrescu asserted that the pointer-like interface for iterators
 is a Bad Thing
\begin_inset script superscript

\begin_layout Plain Layout
tm
\end_layout

\end_inset

, but I think it makes for a neat syntax, so I will stick with it.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}
\end_layout

\begin_layout Plain Layout

TEST_CASE
\end_layout

\begin_layout Plain Layout

( "Range is constructable from standard collection and is iterable", 
\end_layout

\begin_layout Plain Layout

"[range][init][iterable][stl]" )
\end_layout

\begin_layout Plain Layout

{ 
\end_layout

\begin_layout Plain Layout

	std::vector< int > data { 1, 2, 3 }; 
\end_layout

\begin_layout Plain Layout

	auto range = make_range( data );
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	REQUIRE( *range++ == data[ 0 ] ); 
\end_layout

\begin_layout Plain Layout

	REQUIRE( *range++ == data[ 1 ] ); 
\end_layout

\begin_layout Plain Layout

	REQUIRE( *range++ == data[ 2 ] ); 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
What is required to make this test compile? The most obvious thing is 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!make_range!
\end_layout

\end_inset

 - is that a function or a class? In order to make it as general as possible,
 it should (obviously) be a template, and to take full advantage of type-deducti
on it should be a function returning....what? Some type which exhibits the right
 interface.
 With just the information in the test, we can sketch it out.
 Note that, with the use of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!auto!
\end_layout

\end_inset

, the actual type is never named.
 This isn't a crucial observation, but does give us a lot of leeway on the
 choice of name.
 I have been unimaginitive, however.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}
\end_layout

\begin_layout Plain Layout

template< typename iterator_type > 
\end_layout

\begin_layout Plain Layout

class iterable_range 
\end_layout

\begin_layout Plain Layout

{ 
\end_layout

\begin_layout Plain Layout

	public: 
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	iterable_range( iterator_type begin, iterator_type end ) 
\end_layout

\begin_layout Plain Layout

		: pos{ begin }, end_pos{ end } 
\end_layout

\begin_layout Plain Layout

	{ }
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	auto operator*() const -> typename iterator_type::value_type 
\end_layout

\begin_layout Plain Layout

	{ 
\end_layout

\begin_layout Plain Layout

		return *pos; 
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	auto operator++( int ) -> iterable_range 
\end_layout

\begin_layout Plain Layout

	{ 
\end_layout

\begin_layout Plain Layout

		iterable_range tmp{ *this }; 
\end_layout

\begin_layout Plain Layout

		++pos; 
\end_layout

\begin_layout Plain Layout

		return tmp; 
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	private: 
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	iterator_type pos, end_pos; 
\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

template< typename container_type > 
\end_layout

\begin_layout Plain Layout

auto make_range( const container_type & ctr ) 
\end_layout

\begin_layout Plain Layout

	-> iterable_range< typename container_type::const_iterator > 
\end_layout

\begin_layout Plain Layout

{ 
\end_layout

\begin_layout Plain Layout

	return iterable_range< typename container_type::const_iterator > 
\end_layout

\begin_layout Plain Layout

		{ std::begin( ctr ), std::end( ctr ) }; 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
There is nothing particularly startling about this.
 The 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!iterable_range!
\end_layout

\end_inset

 class just squirrels away a pair of iterators (the observant will already
 have noticed that 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!end!
\end_layout

\end_inset

 isn't used, but its purpose should be obvious!), and the 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!make_range!
\end_layout

\end_inset

 function is really just a convenience for creating an instance of the class.
 The 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!iterable_range!
\end_layout

\end_inset

 is a kind of "proto-range"; it's not terribly useful on its own, but it
 does form the basis for other things.
\end_layout

\begin_layout Section
True to type
\end_layout

\begin_layout Standard
It's already time to do something a bit harder.
 Here's another test.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}
\end_layout

\begin_layout Plain Layout

TEST_CASE
\end_layout

\begin_layout Plain Layout

( "Transformation of elements results in new range leaving originals intact",
 
\end_layout

\begin_layout Plain Layout

"[range][transform]" ) 
\end_layout

\begin_layout Plain Layout

{ 
\end_layout

\begin_layout Plain Layout

	std::vector< int > data { 1, 2, 3 }; 
\end_layout

\begin_layout Plain Layout

	auto range = make_range( data );
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	auto result = select( range, []( int i ) 
\end_layout

\begin_layout Plain Layout

		{ return std::to_string( i ); } );
\end_layout

\begin_layout Plain Layout

	std::string expected[] = { "1", "2", "3" };
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	REQUIRE( *result++ == expected[ 0 ] ); 
\end_layout

\begin_layout Plain Layout

	REQUIRE( *result++ == expected[ 1 ] ); 
\end_layout

\begin_layout Plain Layout

	REQUIRE( *result++ == expected[ 2 ] );
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	REQUIRE( *range++ == data[ 0 ] ); 
\end_layout

\begin_layout Plain Layout

	REQUIRE( *range++ == data[ 1 ] ); 
\end_layout

\begin_layout Plain Layout

	REQUIRE( *range++ == data[ 2 ] ); 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
I already mentioned the idea of having different range types, e.g.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!select!
\end_layout

\end_inset

 provides a "selecting range", and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!where!
\end_layout

\end_inset

 provides a "filtering range".
 The line 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!auto result = select( ...!
\end_layout

\end_inset

 now needs some function 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!select!
\end_layout

\end_inset

, and something to return - a transforming range type.
 It's going to need the same basic operations as the 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!iterable_range!
\end_layout

\end_inset

, and it needs to operate on an underlying range.
 The operations on the new range defer to that underlying range type - which
 in this case is an 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!iterable_range!
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}
\end_layout

\begin_layout Plain Layout

template< typename range_type, typename transformation > 
\end_layout

\begin_layout Plain Layout

class transforming_range 
\end_layout

\begin_layout Plain Layout

{ 
\end_layout

\begin_layout Plain Layout

	public: 
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	transforming_range( range_type r, transformation fn ) 
\end_layout

\begin_layout Plain Layout

		: r{ r }, fn{ fn } 
\end_layout

\begin_layout Plain Layout

	{ }
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	private: 
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	range_type r; 
\end_layout

\begin_layout Plain Layout

	transformation fn; 
\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The incrementing operator should be straightforward enough - it needs to
 increment the underlying range object and return a copy of its previous
 self.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}
\end_layout

\begin_layout Plain Layout

auto operator++( int ) -> transforming_range 
\end_layout

\begin_layout Plain Layout

{ 
\end_layout

\begin_layout Plain Layout

	transforming_range tmp{ *this }; 
\end_layout

\begin_layout Plain Layout

	r++; 
\end_layout

\begin_layout Plain Layout

	return tmp; 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
What about the dereference operator? It needs to call the transformation
 function 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!fn!
\end_layout

\end_inset

 with the current element, and return its result.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}
\end_layout

\begin_layout Plain Layout

auto operator*() const -> ??? 
\end_layout

\begin_layout Plain Layout

{ 
\end_layout

\begin_layout Plain Layout

	return fn( *r ); 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
C++ provides an army of tools for determining the types of things at compile
 time for situations like this.
 The one with the most visibility, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!decltype!
\end_layout

\end_inset

, provides the declared type of an expression - including the result of
 calling a function.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}
\end_layout

\begin_layout Plain Layout

auto fn( int ) -> bool 
\end_layout

\begin_layout Plain Layout

{ 
\end_layout

\begin_layout Plain Layout

	return true; 
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\begin_layout Plain Layout

auto fn( double ) -> int 
\end_layout

\begin_layout Plain Layout

{ 
\end_layout

\begin_layout Plain Layout

	return 10; 
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\begin_layout Plain Layout

auto type = decltype( fn( 10 ) ); // type is bool - type returned if fn
 were called with an int
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This makes determining the result of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!operator*()!
\end_layout

\end_inset

 very simple.
 The only restriction on this use is that both 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!fn!
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!r!
\end_layout

\end_inset

 need to have already been "seen", which leads to the need to declare them
 before they are used in the 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!decltype!
\end_layout

\end_inset

 expression.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}
\end_layout

\begin_layout Plain Layout

private: 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

range_type r; 
\end_layout

\begin_layout Plain Layout

transformation fn;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public: 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

auto operator*() const -> decltype( fn( *r ) ) 
\end_layout

\begin_layout Plain Layout

{ 
\end_layout

\begin_layout Plain Layout

	return fn( *r ); 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
I normally much prefer to declare classes with the 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!public!
\end_layout

\end_inset

 section at the top, where it's most obvious and visible.
 However, it seems a fair trade in this case to allow the use of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!decltype!
\end_layout

\end_inset

 in such a simple fashion.
 The alternative is 
\series bold
much
\series default
 worse! 
\begin_inset Foot
status open

\begin_layout Plain Layout
Alright, you'd need something like 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!auto operator*() const -> typename std::result_of< transformation(
 decltype( *std::declval< range_type >() ) ) >::type!
\end_layout

\end_inset

 I hope you agree that declaring 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!private!
\end_layout

\end_inset

 at the top is a small price to pay!
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
With this addition, the 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!transforming_range!
\end_layout

\end_inset

 class should pass all the tests, after we add the now-trivial 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!select!
\end_layout

\end_inset

 function.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}
\end_layout

\begin_layout Plain Layout

template< typename range_type, typename transformation > 
\end_layout

\begin_layout Plain Layout

auto select( range_type r, transformation fn ) 
\end_layout

\begin_layout Plain Layout

	-> transforming_range< range_type, transformation > 
\end_layout

\begin_layout Plain Layout

{ 
\end_layout

\begin_layout Plain Layout

	return transforming_range< range_type, transformation >{ r, fn }; 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Just the good ones
\end_layout

\begin_layout Standard
Time for another test.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}
\end_layout

\begin_layout Plain Layout

TEST_CASE
\end_layout

\begin_layout Plain Layout

( "Filtering elements contains just the matches", 
\end_layout

\begin_layout Plain Layout

"[range][filter]" ) 
\end_layout

\begin_layout Plain Layout

{ 
\end_layout

\begin_layout Plain Layout

	std::vector< int > data { 1, 2, 3 }; 
\end_layout

\begin_layout Plain Layout

	auto range = make_range( data );
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	auto result = where( range, []( int i ) 
\end_layout

\begin_layout Plain Layout

		{ return i % 2 != 0; } );
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	REQUIRE( *result++ == data[ 0 ] ); 
\end_layout

\begin_layout Plain Layout

	REQUIRE( *result++ == data[ 2 ] ); 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
With all the funky stuff learned implementing the 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!transforming_range!
\end_layout

\end_inset

, implementing a 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!filtering_range!
\end_layout

\end_inset

 to be returned by a 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!where!
\end_layout

\end_inset

 function should be pretty straightforward.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}
\end_layout

\begin_layout Plain Layout

template< typename range_type, typename unary_predicate > 
\end_layout

\begin_layout Plain Layout

class filtering_range 
\end_layout

\begin_layout Plain Layout

{ 
\end_layout

\begin_layout Plain Layout

	private: 
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	range_type r; 
\end_layout

\begin_layout Plain Layout

	unary_predicate fn;
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	public: 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	filtering_range( range_type r, unary_predicate fn ) 
\end_layout

\begin_layout Plain Layout

		: r{ r }, fn{ fn } 
\end_layout

\begin_layout Plain Layout

	{ }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	auto operator*() const -> decltype( *r ) 
\end_layout

\begin_layout Plain Layout

	{ 
\end_layout

\begin_layout Plain Layout

		return *r; 
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	auto operator++( int ) -> filtering_range 
\end_layout

\begin_layout Plain Layout

	{ 
\end_layout

\begin_layout Plain Layout

		filtering_range tmp{ *this }; 
\end_layout

\begin_layout Plain Layout

		r++; 
\end_layout

\begin_layout Plain Layout

		while( !fn( *r ) ) 
\end_layout

\begin_layout Plain Layout

			r++; 
\end_layout

\begin_layout Plain Layout

		return tmp; 
\end_layout

\begin_layout Plain Layout

	} 
\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset

The cleverness is all in 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!operator++()!
\end_layout

\end_inset

, which keeps incrementing until the predicate is false.
 The 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!where!
\end_layout

\end_inset

 function is simplicity itself - almost identical to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!select!
\end_layout

\end_inset

, just returning a different range type.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}
\end_layout

\begin_layout Plain Layout

template< typename range_type, typename filter > 
\end_layout

\begin_layout Plain Layout

auto where( range_type r, filter fn ) 
\end_layout

\begin_layout Plain Layout

	-> filtering_range< range_type, filter > 
\end_layout

\begin_layout Plain Layout

{ 
\end_layout

\begin_layout Plain Layout

	return filtering_range< range_type, filter >{ r, fn }; 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Run the tests....and they all pass.
 Time for the next one....
\end_layout

\begin_layout Section
Wait a moment!
\end_layout

\begin_layout Standard
Once again, the observant among you will have already spotted the completely
 fatal flaws in that code.
 Just to labour the point, here's a test that exposes one of them.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}
\end_layout

\begin_layout Plain Layout

TEST_CASE
\end_layout

\begin_layout Plain Layout

( "Filtering range returns correct matches when first element is a mismatch",
 
\end_layout

\begin_layout Plain Layout

"[range][filter][empty]" ) 
\end_layout

\begin_layout Plain Layout

{ 
\end_layout

\begin_layout Plain Layout

	std::vector< int > data { 2, 3, 4 }; 
\end_layout

\begin_layout Plain Layout

	auto range = make_range( data );
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	auto result = where( range, []( int i ) 
\end_layout

\begin_layout Plain Layout

		{ return i % 2 != 0; } );
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	REQUIRE( *result++ == data[ 1 ] ); 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset

The problem here is that the filtering range is fine if the first element
 in the range matches the predicate.
 In any other case, it fails the test.
 Hopefully, this starts a chain of thought leading to questions like "what
 if no elements match?" and then "what if the initial range is empty?".
 
\series bold
Now
\series default
 we know why the 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!iterable_range!
\end_layout

\end_inset

 has an 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!end!
\end_layout

\end_inset

 iterator! We need some sort of check that the range object is valid - that
 it hasn't run out of elements.
 Fortunately, it is trivial to implement a safe conversion to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!bool!
\end_layout

\end_inset

 on all three of our range types.
 For 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!iterable_range!
\end_layout

\end_inset

, it returns 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!false!
\end_layout

\end_inset

 if 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!pos==end_pos!
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!true!
\end_layout

\end_inset

 otherwise.
 For 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!transforming_range!
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!filtering_range!
\end_layout

\end_inset

, it simply returns the value for the underlying range.
 C++ provides an 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!explicit!
\end_layout

\end_inset

 conversion operator - which means the new function won't take part in any
 arithmetic or otherwise unsafe operations.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}
\end_layout

\begin_layout Plain Layout

explicit iterable_range::operator bool() const 
\end_layout

\begin_layout Plain Layout

{ 
\end_layout

\begin_layout Plain Layout

	return pos != end_pos; 
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\begin_layout Plain Layout

explicit transforming_range::operator bool() const 
\end_layout

\begin_layout Plain Layout

{ 
\end_layout

\begin_layout Plain Layout

	return !!r; 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The slightly odd 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{!!r}
\end_layout

\end_inset

 says what it does: "not not", invoking the underlying range's 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!bool!
\end_layout

\end_inset

 conversion.
 Because the conversion is 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!explicit!
\end_layout

\end_inset

, just 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!return r;!
\end_layout

\end_inset

 won't work, of course! 
\begin_inset Foot
status open

\begin_layout Plain Layout
More verbose but perhaps more descriptive might be 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!return static_cast< bool >( r );!
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
.
\end_layout

\begin_layout Standard
With the addition of this rather important facility, we can add a helper
 function to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!filtering_range!
\end_layout

\end_inset

 called 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!find_next_match!
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}
\end_layout

\begin_layout Plain Layout

void find_next_match() 
\end_layout

\begin_layout Plain Layout

{ 
\end_layout

\begin_layout Plain Layout

	while( r && !fn( *r ) ) 
\end_layout

\begin_layout Plain Layout

		++r; 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This function is invoked by 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!operator*()!
\end_layout

\end_inset

 (thus making 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!filtering_range!
\end_layout

\end_inset

 lazy-evaluated), so finds the first matching element.
 The increment operator also needs to invoke it to ensure a range with no
 further matches becomes invalidated.
\end_layout

\begin_layout Standard
This implies that client code must first check that the range is valid before
 invoking 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!operator*()!
\end_layout

\end_inset

 
\begin_inset Foot
status open

\begin_layout Plain Layout
The "functional" approach to this problem is 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!any!
\end_layout

\end_inset

, which returns 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!false!
\end_layout

\end_inset

 if a range contains no elements
\end_layout

\end_inset

., and so 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!operator bool()!
\end_layout

\end_inset

 must 
\emph on
also
\emph default
 invoke it in order to detect a range with no matching elements.
\end_layout

\begin_layout Standard
Time for some more tests!
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}
\end_layout

\begin_layout Plain Layout

TEST_CASE
\end_layout

\begin_layout Plain Layout

( "Filtering range is immediately invalid when no elements match", 
\end_layout

\begin_layout Plain Layout

"[range][filter][nomatch]" ) 
\end_layout

\begin_layout Plain Layout

{ 
\end_layout

\begin_layout Plain Layout

	std::vector< int > data { 2, 3, 4 }; 
\end_layout

\begin_layout Plain Layout

	auto range = make_range( data );
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	auto result = where( range, []( int ) { return false; } );
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	REQUIRE( ! result ); 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

TEST_CASE
\end_layout

\begin_layout Plain Layout

( "Filtering range returns correct matches when first element is a mismatch",
 
\end_layout

\begin_layout Plain Layout

"[range][filter][empty]" ) 
\end_layout

\begin_layout Plain Layout

{ 
\end_layout

\begin_layout Plain Layout

	std::vector< int > data { 2, 3, 4 }; 
\end_layout

\begin_layout Plain Layout

	auto range = make_range( data );
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	auto result = where( range, []( int i ) { return i % 2 != 0; } );
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	REQUIRE( !!result ); 
\end_layout

\begin_layout Plain Layout

	REQUIRE( *result++ == data[ 1 ] ); 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset

Whilst we're at it, we'll add a prefix 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!operator++()!
\end_layout

\end_inset

 to all the range types, too (did I manage to slip that one past you in
 the implementation of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!find_next_match!
\end_layout

\end_inset

?), since efficiency is one of our design principles.
\end_layout

\begin_layout Standard
For 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!filtering_range!
\end_layout

\end_inset

, that operator is used by the postfix version, and looks like the following:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}
\end_layout

\begin_layout Plain Layout

auto operator++() -> filtering_range & 
\end_layout

\begin_layout Plain Layout

{ 
\end_layout

\begin_layout Plain Layout

	++r; 
\end_layout

\begin_layout Plain Layout

	find_next_match(); 
\end_layout

\begin_layout Plain Layout

	return *this; 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Now we're really cooking.
 It must be time to turn the world upside down yet again.
\end_layout

\begin_layout Section
Joined up
\end_layout

\begin_layout Standard
It should be fairly clear how to implement 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!take!
\end_layout

\end_inset

 using the techniques already discussed here.
 What's missing is the ability to chain expressions together.
 In fact, our existing API allows a limited form of composing expressions.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}
\end_layout

\begin_layout Plain Layout

auto result = select( 
\end_layout

\begin_layout Plain Layout

		where( []( int i ) { return i % 2 != 0; } ), 
\end_layout

\begin_layout Plain Layout

	[]( int i ) { return i * 2; } );
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This is somewhat unwieldy, however, especially when composing more than
 a small number of expressions.
\end_layout

\begin_layout Standard
As already noted, we could add a common base class declaring all the high-level
 functionality like 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!select!
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!where!
\end_layout

\end_inset

 and so on.
 The trouble with this approach is that it's inflexible; it would be difficult
 to extend with new operations.
 
\end_layout

\begin_layout Standard
It's not possible to overload 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!operator.()!
\end_layout

\end_inset

 in C++, so directly mimicking the syntax of extension methods is out, but
 there are other operators we could use.
 There is something appealing about hijacking the "pipe" operation common
 in filesystem operations.
 Time for another test.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}
\end_layout

\begin_layout Plain Layout

TEST_CASE
\end_layout

\begin_layout Plain Layout

( "Range results can be composed using simple syntax", 
\end_layout

\begin_layout Plain Layout

"[range][composition]" ) 
\end_layout

\begin_layout Plain Layout

{ 
\end_layout

\begin_layout Plain Layout

	std::vector< int > data { 1, 2, 3 }; 
\end_layout

\begin_layout Plain Layout

	auto range = make_range( data );
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	auto result = range | where( []( int i ) { return i % 2 != 0; } )
\end_layout

\begin_layout Plain Layout

						| select( []( int i ) { return i * 10; } );
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	REQUIRE( *result++ == data[ 0 ] * 10 ); 
\end_layout

\begin_layout Plain Layout

	REQUIRE( *result++ == data[ 2 ] * 10 ); 
\end_layout

\begin_layout Plain Layout

	REQUIRE( ! result ); 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The main thing to note here is that the signatures of the range functions
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!select!
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!where!
\end_layout

\end_inset

 have changed - they no longer take a range object - almost as if the range
 is being passed in through some "standard input".
 This suggests some global operator, perhaps like this:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}
\end_layout

\begin_layout Plain Layout

template< typename left_range_type, typename right_range_type > 
\end_layout

\begin_layout Plain Layout

auto operator|( left_range_type left, right_range_type right ) 
\end_layout

\begin_layout Plain Layout

	-> ??? 
\end_layout

\begin_layout Plain Layout

{ 
\end_layout

\begin_layout Plain Layout

	??? 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The question is - what should it return? Perhaps it would be simpler to
 see the solution to this using actual named funtions instead of overloaded
 operators.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}
\end_layout

\begin_layout Plain Layout

auto result = range
\end_layout

\begin_layout Plain Layout

	.apply( where( []( int i ) { return i % 2 != 0; } ) ) 
\end_layout

\begin_layout Plain Layout

	.apply( select( []( int i ) { return i * 10; } ) );
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This is similar enough to actual chaining, there appears to be some merit
 to following it to see where it leads.
\end_layout

\begin_layout Standard
The first obstacle is this redefinition of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!select!
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!where!
\end_layout

\end_inset

.
 To take 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!where!
\end_layout

\end_inset

 as an example, it cannot construct an instance of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!filtering_range!
\end_layout

\end_inset

, because that type requires an underlying range object on which to operate.
 The range object isn't supplied until 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!apply!
\end_layout

\end_inset

 is called - whatever that is.
 It looks from here very much like a member function common to all range
 types.
 Given that 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!where!
\end_layout

\end_inset

 can't return a 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!filtering_range!
\end_layout

\end_inset

, but must capture the filtering predicate somehow, another intermediate
 type is indicated.
 This intermediate is what gets passed to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!apply!
\end_layout

\end_inset

, and is a factory for the real range type.
 The 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!apply!
\end_layout

\end_inset

 function then invokes that factory to create a real range type.
\end_layout

\begin_layout Standard
One approach to this might be to have a separate intermediate factory for
 every range type; this would certainly make the implementation simple:
 the 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!filtering_range!
\end_layout

\end_inset

 would have a 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!filtering_range_factory!
\end_layout

\end_inset

, and the implementation of that would know how to construct a 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!filtering_range!
\end_layout

\end_inset

 given an underlying range object to construct it with.
\end_layout

\begin_layout Standard
However, for the cases in this example at least, there is a more general
 solution.
 Once again we look to Andrei Alexandrescu, and make use of a simple policy
 template.
 The 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!where!
\end_layout

\end_inset

 function "knows" it requires a 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!filtering_range!
\end_layout

\end_inset

, but has insufficient data or template parameters to actually create one.
 If the 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!filtering_range_factory!
\end_layout

\end_inset

 makes use of a template-template parameter, it can create a 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!filtering_range!
\end_layout

\end_inset

 when all the parameters required are available.
 This can be generalised out to a factory that can create any range type
 that takes 2 template parameters.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}
\end_layout

\begin_layout Plain Layout

template< template< typename, typename > class range_type, typename expression_t
ype > 
\end_layout

\begin_layout Plain Layout

class range_factory 
\end_layout

\begin_layout Plain Layout

{ 
\end_layout

\begin_layout Plain Layout

	public: 
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	range_factory( expression_type action ) 
\end_layout

\begin_layout Plain Layout

		: action{ action } 
\end_layout

\begin_layout Plain Layout

	{ }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	template< typename range_of > 
\end_layout

\begin_layout Plain Layout

	auto operator()( range_of r ) const 
\end_layout

\begin_layout Plain Layout

		-> range_type< range_of, expression_type > 
\end_layout

\begin_layout Plain Layout

	{ 
\end_layout

\begin_layout Plain Layout

		return range_type< range_of, expression_type >{ r, action }; 
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	private: 
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	expression_type action; 
\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Now, the 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!where!
\end_layout

\end_inset

 function instantiates the factory with the required range 
\emph on
type
\emph default
 (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!filtering_range!
\end_layout

\end_inset

), and the predicate function to be captured.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}
\end_layout

\begin_layout Plain Layout

template< typename unary_predicate > 
\end_layout

\begin_layout Plain Layout

auto where( unary_predicate fn ) 
\end_layout

\begin_layout Plain Layout

	-> range_factory< filtering_range, unary_predicate > 
\end_layout

\begin_layout Plain Layout

{ 
\end_layout

\begin_layout Plain Layout

	return range_factory< filtering_range, unary_predicate >{ fn }; 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!select!
\end_layout

\end_inset

 function can do the analogous operation using 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!transforming_range!
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
With this information, we can now implement the 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!apply!
\end_layout

\end_inset

 function.
 Our original vision was to replace 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!apply!
\end_layout

\end_inset

 with an overload of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!operator|()!
\end_layout

\end_inset

.
 Whilst 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!apply!
\end_layout

\end_inset

 needed to be a member function to allow chaining calls together, the overloaded
 operator does 
\series bold
not
\series default
 need to be a member.
 We can sidestep 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!apply!
\end_layout

\end_inset

 altogether, and jump straight to the 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!operator|()!
\end_layout

\end_inset

 implementation, to make our original test for this pass.
 All that's needed is to call the function-call operator on the provided
 factory with the provided underlying range object.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}
\end_layout

\begin_layout Plain Layout

template< typename range_type, typename range_factory_type > 
\end_layout

\begin_layout Plain Layout

auto operator|( range_type range, range_factory_type factory ) 
\end_layout

\begin_layout Plain Layout

	-> decltype( factory( range ) ) 
\end_layout

\begin_layout Plain Layout

{ 
\end_layout

\begin_layout Plain Layout

	return factory( range ); 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

TEST_CASE
\end_layout

\begin_layout Plain Layout

( "Range results can be composed using simple syntax", 
\end_layout

\begin_layout Plain Layout

"[range][composition]" ) 
\end_layout

\begin_layout Plain Layout

{ 
\end_layout

\begin_layout Plain Layout

	std::vector< int > data { 1, 2, 3 }; 
\end_layout

\begin_layout Plain Layout

	auto range = make_range( data );
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	auto result = range | where( []( int i ) { return i % 2 != 0; } ) 
\end_layout

\begin_layout Plain Layout

						| select( []( int i ) { return i * 10; } );
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	REQUIRE( *result++ == data[ 0 ] * 10 ); 
\end_layout

\begin_layout Plain Layout

	REQUIRE( *result++ == data[ 2 ] * 10 ); 
\end_layout

\begin_layout Plain Layout

	REQUIRE( ! result ); 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Extensions
\end_layout

\begin_layout Standard
One of the motivations for the ease of chaining operations was to make the
 API easy to extend.
 Let's see how well we've achieved that, and write 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!take!
\end_layout

\end_inset

.
 The idea is that 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!take!
\end_layout

\end_inset

 produces a range of up to a given number of elements.
 If the original range has fewer than the requested number, then all are
 returned.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}
\end_layout

\begin_layout Plain Layout

TEST_CASE
\end_layout

\begin_layout Plain Layout

( "Range can be limited to a number of elements with take", 
\end_layout

\begin_layout Plain Layout

"[range][take]" ) 
\end_layout

\begin_layout Plain Layout

{ 
\end_layout

\begin_layout Plain Layout

	std::vector< int > data { 1, 2, 3, 4, 5 }; 
\end_layout

\begin_layout Plain Layout

	auto range = make_range( data );
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	auto result = range | take( 2 );
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	REQUIRE( *result++ == data[ 0 ] ); 
\end_layout

\begin_layout Plain Layout

	REQUIRE( *result++ == data[ 1 ] ); 
\end_layout

\begin_layout Plain Layout

	REQUIRE( !result ); 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Implementing the range used - let's call it 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!limited_range!
\end_layout

\end_inset

 - looks straightforward; 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!operator bool()!
\end_layout

\end_inset

 just needs to return 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!false!
\end_layout

\end_inset

 after a certain number of iterations of the underlying range.
 The problem with this one is the implementation of the helper function:
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!take!
\end_layout

\end_inset

 itself.
 Up to this point, the 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!range_factory!
\end_layout

\end_inset

 has had a simple task of creating any one of a number of different range
 types that all had in common their template parameters and construction;
 each one with 2 template parameters, and a constructor that took a range-type
 and functor-type.
\end_layout

\begin_layout Standard
Let's take a quick look at the basic construction of a 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!limited_range!
\end_layout

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}
\end_layout

\begin_layout Plain Layout

template< typename range_type > 
\end_layout

\begin_layout Plain Layout

class limited_range 
\end_layout

\begin_layout Plain Layout

{ 
\end_layout

\begin_layout Plain Layout

	public: 
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	limited_range( range_type r, int count ) 
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Only one template parameter, and the count, which can't be made into a template
 parameter because it might not be a constant.
 The 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!range_factory!
\end_layout

\end_inset

 now needs to do something different, i.e.
 be able to create objects having either one or two template parameters.
\end_layout

\begin_layout Standard
The existing 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!range_factory!
\end_layout

\end_inset

 exists because the type of the underlying range isn't known until the range
 operation (e.g.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!select!
\end_layout

\end_inset

) is invoked via the 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!operator|()!
\end_layout

\end_inset

 mechanism.
 Introducing a new range type with only one template parameter means the
 original "action expression", which for 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!take!
\end_layout

\end_inset

 is just a number, still needs to be captured before the range object is
 created, but the range type is still not known.
\end_layout

\begin_layout Standard
This means the basic mechanism is the same, but the implementation of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!operator()()!
\end_layout

\end_inset

 needs to vary according to the number of template arguments for the target
 range type.
 The ideal solution to this would be to create a partial specialization
 of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!range_factory!
\end_layout

\end_inset

 using variadic templates to represent the differences.
 Something like this:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}
\end_layout

\begin_layout Plain Layout

template< template< typename, typename...
 > class range_type, typename expression_type > 
\end_layout

\begin_layout Plain Layout

struct range_factory 
\end_layout

\begin_layout Plain Layout

{ };
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

template< template< typename, typename, typename...
 > class range_type, typename expression_type > 
\end_layout

\begin_layout Plain Layout

struct range_factory< range_factory< range_type, expression_type > > 
\end_layout

\begin_layout Plain Layout

{ };
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This would rely on factory types with 2 or more template parameters matching
 the specialisation, and those with only one template parameter matching
 the primary.
 However, the rules of partial specialization don't allow this; the primary
 template's implicit types (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!range_type!
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!expression_type!
\end_layout

\end_inset

) aren't distinguishable from the specialization, so the second struct is
 ambiguous.
\end_layout

\begin_layout Standard
It doesn't prevent a new factory type which understands how to create types
 having only one template parameter, and having the 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!take!
\end_layout

\end_inset

 function use it directly.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}
\end_layout

\begin_layout Plain Layout

template< template< typename > class range_type, typename expression_type
 > 
\end_layout

\begin_layout Plain Layout

class range_factory_1 
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
It is otherwise idential to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!range_factory!
\end_layout

\end_inset

, except for 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!operator()()!
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}
\end_layout

\begin_layout Plain Layout

template< typename range_of > 
\end_layout

\begin_layout Plain Layout

auto operator()( range_of r ) const 
\end_layout

\begin_layout Plain Layout

	-> range_type< range_of > 
\end_layout

\begin_layout Plain Layout

{ 
\end_layout

\begin_layout Plain Layout

	return range_type< range_of >{ r, action }; 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The only difference here is the number of template arguments provided to
 the 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!range_type!
\end_layout

\end_inset

 in the factory function.
\end_layout

\begin_layout Standard
This solution works, but it does require any other extensions to know which
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!...factory!
\end_layout

\end_inset

 class to invoke.
 It's not a catastrophe, but it could be made easier.
 Instead of variadic templates and specialization, we turn to ordinary function
 overloading to come to the rescue.
 Instead of creating the correct factory type directly, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!take!
\end_layout

\end_inset

 can use a call to a function which is overloaded based on the same template-tem
plate upon which we wished we could specialize 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!range_factory!
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}
\end_layout

\begin_layout Plain Layout

template< template< typename, typename > class range_type, typename expression_t
ype > 
\end_layout

\begin_layout Plain Layout

auto make_range_factory( expression_type expr ) 
\end_layout

\begin_layout Plain Layout

	-> range_factory< range_type, expression_type > 
\end_layout

\begin_layout Plain Layout

{ 
\end_layout

\begin_layout Plain Layout

	return range_factory< range_type, expression_type >{ expr }; 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

template< template< typename > class range_type, typename expression_type
 > 
\end_layout

\begin_layout Plain Layout

auto make_range_factory( expression_type expr ) 
\end_layout

\begin_layout Plain Layout

	-> range_factory_1< range_type, expression_type > 
\end_layout

\begin_layout Plain Layout

{ 
\end_layout

\begin_layout Plain Layout

	return range_factory_1< range_type, expression_type >{ expr }; 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This pair of function overloads selects the correct factory class to construct
 based on the number of template parameters required by the 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!range_type!
\end_layout

\end_inset

 template-template.
 Any function that now needs a 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!range_factory!
\end_layout

\end_inset

 or 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!range_factory_1!
\end_layout

\end_inset

 can just use the overloaded function and provide the correct type for that
 factory to create, and overloading will do the rest.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}
\end_layout

\begin_layout Plain Layout

auto take( size_t count ) 
\end_layout

\begin_layout Plain Layout

	-> decltype( make_range_factory< limited_range >( count ) ) 
\end_layout

\begin_layout Plain Layout

{ 
\end_layout

\begin_layout Plain Layout

	return make_range_factory< limited_range >( count ); 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

template< typename unary_predicate > 
\end_layout

\begin_layout Plain Layout

auto where( unary_predicate fn ) 
\end_layout

\begin_layout Plain Layout

	-> decltype( make_range_factory< filtering_range >( fn ) ) 
\end_layout

\begin_layout Plain Layout

{ 
\end_layout

\begin_layout Plain Layout

	return make_range_factory< filtering_range >{ fn }; 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Here is the 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!take!
\end_layout

\end_inset

 function implemented to use the new factory factory function (!), and using
 the same function return type deduction as used previously, with 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!decltype!
\end_layout

\end_inset

.
 I've also re-implemented 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!where!
\end_layout

\end_inset

 to show the usage is identical; these two functions make use of 
\emph on
different
\emph default
 range factory types, but that is merely "implementation detail".
\end_layout

\begin_layout Standard
It's not unreasonable to imagine range implementation classes needing more
 template arguments.
 In such cases, the corresponding 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!range_factory_N!
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!make_range_factory!
\end_layout

\end_inset

 overload pair would be needed, but in practice, one and two template parameter
 range types cover most of the most useful things.
\end_layout

\begin_layout Section
All done
\end_layout

\begin_layout Standard
This article set out with the stated aim of implementing something not dissimila
r to the simple C# LINQ expression which does simple filtering, transformation
 and range-limiting.
 With the implementation so far, it's 
\series bold
very
\series default
 similar (but not exactly the same, for some good reasons).
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[language={[Sharp]C}]
\end_layout

\begin_layout Plain Layout

var result = container
\end_layout

\begin_layout Plain Layout

	.Where( item => item.Id == expected ) 
\end_layout

\begin_layout Plain Layout

	.Select( filtered => filtered.Count.ToString() ) 
\end_layout

\begin_layout Plain Layout

	.Take( 2 );
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}
\end_layout

\begin_layout Plain Layout

auto result = range 
\end_layout

\begin_layout Plain Layout

	| where( [&]( const thing & t ) { return t.name == expected; } ) 
\end_layout

\begin_layout Plain Layout

	| select( []( const thing & t ) { return to_string( t.count ); } ) 
\end_layout

\begin_layout Plain Layout

	| take( 2 );
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
There was a mention in passing, however, of being able to interoperate with
 the existing C++ Standard Library implementations, without losing efficiency.
 The high-level API achieved here is certainly not just a thin wrapper around
 C++ iterators; it provides a very rich and type-safe platform which is
 extended fairly easily (at least, no more difficult than extending C#'s
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!IEnumerable!
\end_layout

\end_inset

 facilities).
 How hard is it to go the extra step, and allow this new range type to play
 nicely with C++ algorithms?
\end_layout

\begin_layout Standard
With some restrictions, it's very simple.
 Those restrictions again are inspired by C#'s LINQ: 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!IEnumerable!
\end_layout

\end_inset

 is an 
\emph on
immutable
\emph default
 interface.
 You cannot modify elements of it, nor modify the range represented by it,
 without going via some concrete container type, which in C# means calling
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!ToList()!
\end_layout

\end_inset

 or 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!ToArray()!
\end_layout

\end_inset

 on the range.
\end_layout

\begin_layout Standard
I believe immutability isn't an unreasonable restriction on this kind of
 programming.
 With increased focus on concurrency and multi-processing to achieve better
 performance, and with both of those techniques benefiting greatly from
 the use of immutable data, making the ranges that this API operates on
 immutable isn't a restriction, it's a design principle.
\end_layout

\begin_layout Standard
Turning an immutable range into mutable data which works with mutating algorithm
s requires the C++ equivalent of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!ToList()!
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Let's see if we can express what is required for that in another test.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}
\end_layout

\begin_layout Plain Layout

TEST_CASE
\end_layout

\begin_layout Plain Layout

( "Range can be used to populate a standard lib container", 
\end_layout

\begin_layout Plain Layout

"[range][export][stl]" ) 
\end_layout

\begin_layout Plain Layout

{ 
\end_layout

\begin_layout Plain Layout

	std::vector< int > data { 1, 2, 3 }; 
\end_layout

\begin_layout Plain Layout

	auto range = make_range( data ) 
\end_layout

\begin_layout Plain Layout

		| select( []( int x ) { return std::to_string( x ); } );
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	std::vector< std::string > result { begin( range ), end( range ) };
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	REQUIRE( result.size() == data.size() ); 
\end_layout

\begin_layout Plain Layout

	REQUIRE( std::to_string( data[ 0 ] ) == result[ 0 ] ); 
\end_layout

\begin_layout Plain Layout

	REQUIRE( std::to_string( data[ 1 ] ) == result[ 1 ] ); 
\end_layout

\begin_layout Plain Layout

	REQUIRE( std::to_string( data[ 2 ] ) == result[ 2 ] ); 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This highlights the fact that in C++, containers and algorithms work with
 
\emph on
pairs
\emph default
 of iterators - the 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline![begin, end)!
\end_layout

\end_inset

 "range", whereas the range types described in this article encapsulate
 the pair of iterators into a single item.
 Implementing 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!begin!
\end_layout

\end_inset

 for the range type looks straightforward - perhaps the necessary operations
 (only an 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!InputIterator!
\end_layout

\end_inset

's operations are required) could be added to the range types, so equivalence
 operators 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{!=}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{==}
\end_layout

\end_inset

.
 The possible difficulty might be in implementing 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!end!
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
There is also precedence for writing 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!end!
\end_layout

\end_inset

 when an end position isn't known: 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!std::ostream_iterator!
\end_layout

\end_inset

 uses a sentry type (effectively an invalid position created by the default
 constructor), so a similar technique could be employed here.
 The only way to find the end of a Range is to consume it, which is obviously
 undesirable.
\end_layout

\begin_layout Standard
There's more to a C++ Iterator than 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{++}
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{*}
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{!=}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{==}
\end_layout

\end_inset

 however, in practice.
 There are some embedded typedefs to consider as well, which is usually
 captured by inheriting from 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!std::iterator!
\end_layout

\end_inset

.
 So, instead of making changes to all of the range types, or some common
 base class, it seems to be a better separation of concerns to implement
 the necessary iterator type separately.
 As already noted, only the operations and types associated with 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!InputIterator!
\end_layout

\end_inset

s are needed if range types are immutable.
 Most of the required operations are easy enough to write.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}
\end_layout

\begin_layout Plain Layout

template< typename range_type, typename value_type > 
\end_layout

\begin_layout Plain Layout

class range_input_iterator 
\end_layout

\begin_layout Plain Layout

	: public std::iterator< std::input_iterator_tag, value_type > 
\end_layout

\begin_layout Plain Layout

{ 
\end_layout

\begin_layout Plain Layout

	public: 
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	range_input_iterator( const range_type & r ) 
\end_layout

\begin_layout Plain Layout

		: r{ r } 
\end_layout

\begin_layout Plain Layout

	{ }
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	auto operator==( const range_input_iterator & ) const -> bool 
\end_layout

\begin_layout Plain Layout

	{ 
\end_layout

\begin_layout Plain Layout

		??? 
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	auto operator!=( const range_input_iterator & r ) const -> bool 
\end_layout

\begin_layout Plain Layout

	{ 
\end_layout

\begin_layout Plain Layout

		return !operator==( r ); 
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	auto operator++() -> range_intput_iterator & 
\end_layout

\begin_layout Plain Layout

	{ 
\end_layout

\begin_layout Plain Layout

		++r; 
\end_layout

\begin_layout Plain Layout

		return *this; 
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	auto operator*() const -> value_type 
\end_layout

\begin_layout Plain Layout

	{ 
\end_layout

\begin_layout Plain Layout

		return *r; 
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	private: 
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	range_type r; 
\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The sticking point is to decide how to implement 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{operator==()}
\end_layout

\end_inset

.
 How to compare two ranges to see if their current positions are the same,
 in the same range of iterators? Time to step back and consider: how would
 the 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!std::vector!
\end_layout

\end_inset

 constructor taking two iterators be implemented? Something very like:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}
\end_layout

\begin_layout Plain Layout

vector( iterator b, iterator e ) 
\end_layout

\begin_layout Plain Layout

{ 
\end_layout

\begin_layout Plain Layout

	while( b != e ) 
\end_layout

\begin_layout Plain Layout

		push_back( *b++ ); 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The point here is that the most important consideration is the comparison
 to the "end" position, which our ranges 
\emph on
already
\emph default
 
\emph on
do
\emph default
 to determine 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{operator bool()}
\end_layout

\end_inset

, needed for other things internally.
 If we make the assumption that such comparisons are only ever between a
 valid range and the end of the same range, then 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{operator==()}
\end_layout

\end_inset

 can use 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{operator bool()}
\end_layout

\end_inset

 - two ranges always compare equal if the first is valid.
\end_layout

\begin_layout Standard
A side effect of this is that the right-hand-side of an expression 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!range_l == range_r!
\end_layout

\end_inset

 is never used, so it doesn't matter what 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!end!
\end_layout

\end_inset

 returns - it doesn't even need to be a default-constructed sentry value
 (which would be difficult, given the lack of default constructors of the
 range types).
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}
\end_layout

\begin_layout Plain Layout

auto operator==( const range_input_iterator & ) const -> bool 
\end_layout

\begin_layout Plain Layout

{ 
\end_layout

\begin_layout Plain Layout

	return !r; 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The implementations of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!begin!
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!end!
\end_layout

\end_inset

 therefore become:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}
\end_layout

\begin_layout Plain Layout

template< typename range_type > 
\end_layout

\begin_layout Plain Layout

auto begin( range_type r ) 
\end_layout

\begin_layout Plain Layout

	-> range_input_iterator< range_type, decltype( *r ) > 
\end_layout

\begin_layout Plain Layout

{ 
\end_layout

\begin_layout Plain Layout

	return range_input_iterator< range_type, decltype( *r ) >{ r }; 
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\begin_layout Plain Layout

template< typename range_type > 
\end_layout

\begin_layout Plain Layout

auto end( range_type r ) 
\end_layout

\begin_layout Plain Layout

	-> range_input_iterator< range_type, decltype( *r ) > 
\end_layout

\begin_layout Plain Layout

{ 
\end_layout

\begin_layout Plain Layout

	return range_input_iterator< range_type, decltype( *r ) >{ r }; 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
That's not a printing error: they are identical in implementation.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!end!
\end_layout

\end_inset

 merely has to return something of the correct 
\emph on
type
\emph default
 - it is never used, not even to compare with anything.
 
\end_layout

\begin_layout Standard
A side effect of this is that interoperability with non-mutating C++ algorithms
 is achieved for free, for example 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}
\end_layout

\begin_layout Plain Layout

std::copy( begin( r ), end( r ), std::back_inserter( my_list ) );
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset

.
\end_layout

\begin_layout Section
To conclude
\end_layout

\begin_layout Standard
There have been a few range libraries developed for C++ over recent years,
 but none seem to have had the same take-up as ranges have in D, for example.
 I think it's partly because C++ iterator pairs have become such a central
 part of writing C++ programs that use the Standard Library, partly because
 such range libraries that there are are either clunky to use, or have disappoin
ting behaviour regarding the C++ Standard Library, and partly because there
 are actually no really compelling use cases for them that can't be achieved
 using other techniques.
\end_layout

\begin_layout Standard
In this article, I set out to demonstrate some uses for a very lightweight
 range type that's very easy to use, and provides facilities that are very
 widely used in a different language - C# - which in turn took the ideas
 of functional languages and coupled them with what some people describe
 as the ultimate declarative language, SQL.
\end_layout

\begin_layout Standard
C++ has many functional facilities, and many of the standard algorithms
 mirror functional constructs.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!std::transform!
\end_layout

\end_inset

 is essentially a list comprehension, but lacks the brevity and simplicity
 of transformations in truly functional languages, at least in part because
 it uses two iterator-pairs to represent separate ranges.
\end_layout

\begin_layout Standard
The C# 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!Select!
\end_layout

\end_inset

 expression to transform one 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!IEnumerable!
\end_layout

\end_inset

 into another captures the simple case that is most common - turn every
 element into a new range of some new type - and C++'s 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!transform!
\end_layout

\end_inset

 doesn't really even compete.
 A simple range type for C++ overcomes the problems with having that simplicity,
 whilst still allowing simple and efficient interoperability with existing
 C++ Standard Library facilities.
\end_layout

\begin_layout Standard
All the code in this article compiles with GCC 4.6.3 (with -std=c++0x) on
 Ubuntu, and GCC 4.8.1 (with -std=c++11) and Microsoft Visual Studio 2013
 CP on Windows.
 It's available from 
\begin_inset CommandInset href
LatexCommand href
target "https://github.com/essennell/narl"

\end_inset

.
\end_layout

\begin_layout Section
Acknowledgements
\end_layout

\begin_layout Standard
Many thanks to Andy Sawyer and Roger Orr for fixing some of my misunderstandings
 of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline!decltype!
\end_layout

\end_inset

 and trailing return types, Jon Wakely for helping me understand 
\series bold
why
\series default
 partial specialisation of types based just on the number of template-template
 parameters doesn't work, and to Frances Buontempo, Roger Orr and Chris
 Oldwood for reading early revisions of the article and spotting my inevitable
 errors.
\end_layout

\begin_layout Section
References
\end_layout

\begin_layout Standard
[1] 
\begin_inset CommandInset href
LatexCommand href
target "http://accu.org/content/conf2009/AndreiAlexandrescu_iterators-must-go.pdf"

\end_inset

.
 
\end_layout

\begin_layout Standard
[2] 
\begin_inset CommandInset href
LatexCommand href
target "http://www.boost.org/doc/libs/1_54_0/libs/range/doc/html/range/reference.html"

\end_inset

 
\end_layout

\begin_layout Standard
[3] 
\begin_inset CommandInset href
LatexCommand href
target "https://github.com/dietmarkuehl/kuhllib/wiki/STL-2.0"

\end_inset

 
\end_layout

\begin_layout Standard
[4] 
\begin_inset CommandInset href
LatexCommand href
target "http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3350.html"

\end_inset

 
\end_layout

\begin_layout Standard
[5] 
\begin_inset CommandInset href
LatexCommand href
target "https://github.com/philsquared/Catch"

\end_inset


\end_layout

\end_body
\end_document
