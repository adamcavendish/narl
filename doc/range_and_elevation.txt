C++11 Range and Elevation
=========================

C++11 provides many features for higher-level programming, but lacks some common ones present in other languages.

=========================

Back in 2009, Andrei Alexandrescu gave a presentation at the ACCU Conference about Ranges. The short version 
is that although you can /represent/ a range in C++98 using a pair of iterators, the /usage/ is cumbersome for most
simple tasks. Even for a simple loop, using iterators can be a trial.

	for( vector< int >::iterator pos = data.begin(); pos != data.end(); ++pos )
	{
		.... do interesting things with ints
	}

The C++ Standard Library provides a simple enough algorithm which improves on this a bit, but you need to provide the
action to be performed as a functor argument, thus losing the locality of reference for that action.

	for_each( data.begin(), data.end(), action );

And all that's just using the iterators the C++ Standard Library gives you; defining your own iterator is notoriously 
complex. So, Andrei introduced a much simpler - and more powerful - abstraction: the Range. 
[http://accu.org/content/conf2009/AndreiAlexandrescu_iterators-must-go.pdf].

There have been a few attempts to implement Andrei's ideas in C++ (he implemented them for D, and they form the basis 
of the D Standard Library) but for one reason or another, it just hasn't caught on. Part of the reason for that is 
that in order to take advantage of this new abstraction as Andrei envisioned it, you need a rewrite of the Standard 
Library that uses Ranges instead of Iterators. For some reason, there seems to be little appetite for this. Some 
implementations have arisen that are interoperable with C++ Standard Library algorithms 
[http://www.boost.org/doc/libs/1_54_0/libs/range/doc/html/range/reference.html], 
[https://github.com/dietmarkuehl/kuhllib/wiki/STL-2.0#andrei-alexandrescus-ranges], but even they appear to not have 
had as much traction in the C++ community at large as might have been hoped. Similarly, there have been proposals to 
the C++ Standards effort [http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3350.html], but still, not much 
apparent interest in something that is little more than a thin wrapper around the existing C++ container types which
are, after all, really just iterator factories.

Part of the reason Andrei himself implemented his idea of Ranges in D, rather than C++, was that C++ at the time 
didn't provide good enough language support to make it straightforward. In particular, there was a C++ proposal at the
time for "auto" variable declarations, which would have been crucial, but had experimental support in only one widely
used compiler. Now, C++ officialy has {auto}, and it's very widely supported. But not a widely-used - let alone 
standard - range type.

All of this is highly relevant, of course, but misses an important point: what do these range types actually achieve?
What problem are they attempting to solve?

Time for a quick segue into a different world....


